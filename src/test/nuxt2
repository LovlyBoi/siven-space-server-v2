# Nuxt.js

Nuxt.js 是一个基于 Vue 的框架，在 Vue 的基础上进行了封装，使得开发者免于开发时复杂的配置。

Nuxt.js 很重要的一点是支持**同构渲染**。

## 前端的渲染模式

前端项目通常有三种渲染模式，分别是：客户端渲染（CSR）、服务器端渲染（SSR）和同构渲染（Universal Rendering）。

### 客户端渲染

我们平时进行的 Vue 开发就是客户端渲染。客户端从服务器下载 html 文件，解析后接着下载 JS 资源，执行 JS 脚本将页面渲染到屏幕上。

这种渲染模式，优点是开发时不需要考虑兼顾双端，因为 JS 只会运行在浏览器上，不会跑在 Node 端，而且服务器压力小，只需要返回静态资源。但是缺点也很明显，首屏速度非常慢（因为要 JS 加载好才渲染），而且 SEO 极差（主要内容只有一个 div 标签，剩下都是运行时挂载上去的）。

### 服务器端渲染

服务器端渲染并不新鲜，之前的开发模式都是服务器端渲染，比如 PHP、JSP。

服务器端渲染由服务器生成好 包含主要内容的 HTML 文件，发送给客户端进行渲染。这样做白屏时间短，而且 SEO 优化好。但是占用服务器资源，而且用户体验不好，每次都需要跳转新的页面。

### 同构渲染

同构渲染是综合了以上两者，产出的一个这种方案。这种渲染模式由 Node 服务器先执行一部分 JS 代码，让内容先生成为 HTML 字符串，然后将有内容的 HTML 发送给客户端，客户端将已经渲染的节点和框架运行得到的虚拟节点做映射（Hydration，注水），接着执行运行时的 JS 代码。

这样做，白屏时间短、SEO 优化好，但是依旧会占用服务器资源，但是占用的相对少。而且需要在开发时考虑到哪些 JS 代码要在 Node 端执行，哪些要在客户端执行。

### Vue 的服务器渲染

Vue 由于使用了虚拟节点，所以对服务器渲染的支持也很好，只需要调用 Vue 的服务端渲染的渲染器，Vue 就不会生成 DOM 节点，而是对应的 HTML 字符串。

## 创建项目

安装并使用 `create-nuxt-app`：

```shell
$ yarn create nuxt-app <project-name>
```

## 生命周期

一个 Nuxt 应用会先在 Node 服务器运行，这其中可能会去请求其他的后端服务器（比如说鉴权，向 Java 服务器请求 token），然后将生成的 HTML 发给浏览器，浏览器负责将 HTML 激活（Vue 不再挂载元素，而是与已有的元素创建连接）。

![Nuxt2-Lifecircle.jpg](https://s2.loli.net/2022/09/03/SwN2FJMRWztmcfL.jpg)

### 服务器端

服务端将依次执行以下生命周期：

#### nuxtServerInit

服务端调用的第一个生命周期钩子，写在 Vuex actions 中，在服务器初始化后调用。

```js
// @/store/index.js
export const actions = {
  nuxtServerInit(store, context) {
    // store 即正常 Vuex 会传入的 store
    // context 则是调用时传入的 nuxt 上下文
  }
}
```

一般用于在渲染页面之前存储数据到 Vuex 中，比如获取 token 等，是全局的，不是单独页面的。

#### Route Middleware

这个钩子类似路由守卫，会在 page 组件被渲染前调用。

```js
// @/middleware/auth.js
export default function(context) { // 暴露一个函数
  
}

// @/nuxt.config.js
export default {
  middleware: 'auth' // 所有页面在渲染前都会调用
}
```

如果想要配置页面级别的 middleware：

```vue
<!-- @/pages/about.vue -->

<script>
export default {
  middleware: 'auth', // 页面级 middleware
  // 如果只有一个组件用，也可以这么写。
  middleware(context) {
    
  }
}
</script>
```

钩子接受一个 `context` 对象，这个 `context` 对象：

```js
function(context) {
  // 都有的属性
  const {
    app,
    store, // Vuex 的 store
    route, // Vue-Router 的 Route 对象
    params,
    query,
    env,
    isDev,
    isHMR,
    redirect,
    error,
    $config
  } = context
  // 服务端有的属性
  if (process.server) {
    const { req, res, beforeNuxtRender } = context
  }
  // 客户端有的属性
  if (process.client) {
    const { from, nuxtState } = context
  }
}
```

#### validate

validate 一般用于检验页面动态路由参数是否正确（所以只用于页面）。

```vue
// @/pages/about.vue
<script>
export default {
  validate({ params, query, store }) {
		return true // 如果路由参数正确，放行
    return false // 阻止 nuxt 渲染页面，并展示 error 页面。如果什么都不返回，返回 undefined，相当于返回了 false
    // 比如 校验id是否是数字
    return /^\d+$/.test(query.id)
  }
}
</script>
```

#### asyncData

asyncData 会在**页面组件**每次加载之前被调用，允许我们在服务器端获取数据，在渲染组件之前就异步拿到数据（也就是说，在 HTML 发到客户端之前就有这个异步数据了）。

```vue
<script>
export default {
  data() {
    return {
      value: 'default'
    }
  },
  // asyncData 接受 context 作为参数，返回的对象会被合并进 data 中
  async asyncData(context) {
    // 发请求，获取数据
    const value = await axios.get('/api')
    return {
      value,
    }
  }
}
</script>
```

#### beforeCreate

Vue 生命周期。

#### created

Vue 生命周期。

#### fetch

`fetch` 方法会在组件每次加载前（`created` 钩子之后）被调用（不仅仅是页面组件）。

和 `asyncData` 类似，都是用来异步获取数据的，和 `asyncData` 不同的是 `fetch` 不会设置组件的数据（当然你可以自己手动设置）。`fetch` 会在服务器的 `created` 之后调用（通过对应的 this 上下文调用，所以可以使用 this），修改好组件数据，所以发送到客户端的时候，数据已经在页面上了。

```vue
<script>
export default {
  data() {
    return {
      msg: 'default'
    }
  },
  async fetch(context) {
    this.mag = await axios.get('/api')
  }
 }
</script>
```

### 客户端

服务器渲染 Vue 组件后发送给客户浏览器，在客户浏览器中会触发以下生命周期：

#### asyncData

从其他页面跳转过来的，也需要请求数据，所以也会在客户端执行。

#### beforeCreate

Vue 的生命周期。

#### created

Vue 的生命周期。

#### fetch

从其他页面跳转过来的，也会在客户端执行。

#### beforeMount

Vue 的生命周期。

#### mount

Vue 的生命周期。

#### beforeUpdate

Vue 的生命周期。

#### updated

Vue 的生命周期。

#### beforeDestroy

Vue 的生命周期。

#### destroyed

Vue 的生命周期。

## 路由